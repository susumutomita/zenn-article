---
title: "発展トピック"
free: true
---

## zkEVM とゼロ知識証明の活用

### zkEVM の基本概念と動作原理

zkEVM（ゼロ知識Ethereum Virtual Machine）は、Ethereumのスマートコントラクト実行環境（EVM）をゼロ知識証明と組み合わせた新しい仕組みです。通常のEVMと同様にスマートコントラクトを実行しますが、その結果に対してゼロ知識証明（ZK証明）を生成し、信頼性を保証します。 ([What Is a zkEVM? | Chainlink](https://chain.link/education-hub/zkevm))。具体的には、zkEVM上で一連のトランザクションを処理すると、更新後の状態とそれが正しく計算されたことを示す証明が生成され、これをレイヤー1（メインチェイン）に送信します。レイヤー1側では、この証明を検証することで計算の正当性を確認できるため、全ての詳細な計算をしなくても信頼性を担保できます。要するに、zkEVMはEthereumの既存インフラや開発ツールと互換性を保ちつつ、ゼロ知識証明を用いた**ゼロ知識ロールアップ**として高いスループットと低コストを実現する技術です。

### 主要な zkEVM プロジェクト

現在開発・運用が進む主なzkEVMプロジェクトには、**Polygon zkEVM**、**StarkNet**、**Scroll** などがあります。

- Polygon zkEVM: Polygon社が開発するzkEVMロールアップで、2023年3月にメインネットをローンチしました。既に約1,000万件近いトランザクションを処理しており、高い実利用が進んでいます ([The State of zkEVMs: End of 2023 | Immutable Blog](https://www.immutable.com/blog/the-state-of-zkevms-end-of-2023))。Polygon zkEVMはEthereumとほぼ同等のEVM互換性を目指したアプローチを取っており、既存のSolidityコントラクトをそのままデプロイ可能です。プルーフ（証明）には主にZK-SNARKを用いており、プルーフ生成の効率化のため独自実装のクライアントやプローバ（証明生成器）を開発しています。

- StarkNet: StarkWare社によるzkロールアップチェインで、厳密にはEVM互換ではなく新設計の仮想マシン(**Cairo VM**)と言語(**Cairo**)を用いている点が特徴です。StarkNetはVitalik氏の分類でType 4に位置付けられ、EVMの互換性を犠牲にしてでもパフォーマンスや機能拡張を追求するアプローチです。実際、Solidityとの互換レイヤーとして開発されていたWarp（Solidity→Cairoトランスパイラ）は廃止され、エコシステム全体がCairo言語に注力する方針となりました。この大胆な設計により、アカウント抽象化など従来のEVMが苦手とする機能をネイティブに実装しつつ、高い処理性能を目指しています。StarkNetは2021～2022年にかけて段階的に一般公開され、現在はTVL（総預かり資産）1.5億ドル超、月間1,000万件以上のトランザクションを処理するまでに成長しています。

- Scroll: Scrollはコミュニティ主導で開発されているzkEVMプロジェクトで、2023年に2度のテストネットと同年10月にメインネットをローンチしました。Scrollは現在Polygon zkEVMと同様にType 3のzkEVMと位置付けられており、EVMとほぼ同じ動作を実現するためにgethのフォーク版クライアントを使用しています。既存のEthereumコントラクトとの互換性を重視しつつ証明生成を効率化する設計で、将来的にはType 2への移行も見据えています。ScrollもZK-SNARKベースのプローバを採用しており、高速な証明生成と安定したネットワーク運用に注力しています。

### ゼロ知識証明 (ZK-SNARKs, ZK-STARKs) の基礎とブロックチェインへの応用

**ゼロ知識証明**とは、ある主張が真であることを証明する際に、その主張が「真である」という事実以外の情報を一切開示しない暗号学的手法です。 ([zk-SNARK vs zkSTARK - Explained Simple | Chainlink](https://chain.link/education-hub/zk-snarks-vs-zk-starks))。ブロックチェイン文脈では、トランザクションや計算の正当性をプライバシーを保ったまま証明するために活用されています。特に注目されるのが、**ZK-SNARKs**と**ZK-STARKs**という2種類の方式です。

- ZK-SNARKs: SNARKは非常に短い証明で検証も高速ですが、セットアップ時に信頼できるセッティング（trusted setup）を必要とする場合があります。例えば、有名なプライバシー通貨であるZcashは世界で初めてzk-SNARKを実用化し、送金額やアドレスを秘匿したままトランザクションの有効性を証明する「シールド取引」を実現しました。SNARKsの利点は証明サイズが小さく数ミリ秒で検証が完了するほど高速な点にあります。一方で多くの実装では安全な初期設定（複数人で乱数を生成し、その秘密を破棄する儀式）が必要で、万一その秘密が漏洩すると偽の証明を作成できてしまうリスクがあります。この信頼設定への依存は批判も受けており、また従来のSNARKアルゴリズムの多くは量子計算機に対して耐性がないという欠点も指摘されています。

- ZK-STARKs: STARKはSNARKの後発として2018年にEli Ben-Sassonらの論文で提唱された方式です。**透明性**（transparent）の名が示す通り信頼できるセットアップを不要とする点が大きな特徴です。STARKsでは公開可能なランダム性（公開乱数）を用いて証明と検証をするため、事前の秘密共有が不要であり、またハッシュ関数に基づく方式のため量子計算に対しても耐性が高いとされています。ただしデメリットとして、証明サイズがSNARKより大きくなりがちで検証にも時間がかかる（一般にSNARKよりガスコストが高い）点が挙げられます。現在この技術はStarkNetなどで実用化されており、オフチェインで多数のトランザクションをまとめて計算し、その正しさをSTARK証明によってチェイン上で検証する。といった形でスケーラビリティ向上に貢献しています。

ブロックチェインへの応用としては、上述の**ロールアップ（Rollup）**への活用が特に重要です。**ZKロールアップ**では、オフチェインで多数の取引を処理し、その結果のみをゼロ知識証明とともにレイヤー1に投稿します。レイヤー1は投稿された証明（有効性の証明）を検証するだけで済むため、大量のトランザクション処理を圧縮してブロックチェインに取り込めます。これによりイーサリアムの1ブロックあたり処理件数を引き上げつつ、各ユーザーの手数料負担を下げることが可能になります。またゼロ知識証明はプライバシー強化にも利用でき、前述のZcashの他、イーサリアム上でもTornado Cashのように送金元と送金先を秘匿するサービスで活用されました。

総じて、zk-SNARKsやzk-STARKsとEVMの統合（zkEVM）は、レイヤー2でのスケーリングとプライバシー強化の両面でブロックチェイン技術の発展を支える中核的なトピックとなっています。

## EVMの最適化技術

### evmoneやrevmなどの最適化EVM実装

イーサリアムクライアントにおけるEVM実装は複数存在しており、それぞれが処理性能向上のための最適化技術を備えています。代表的なものに**evmone**と**revm**があります。

- evmone: evmoneはEthereum Foundationのチームによって開発されたC++製の高速EVM実装です。 ([GitHub - ethereum/evmone: Fast Ethereum Virtual Machine implementation](https://github.com/ethereum/evmone))。既存クライアント（Gethなど）の内部EVMを差し替える形で利用でき、高速な命令実行を提供します。evmoneには2種類の実行エンジン（インタプリタ）が搭載されています。特に「Advanced」モードでは命令列を解析して**ブロックごとのガスコスト計算**を事前に行います。各命令を関数ポインタのテーブルに展開する**間接スレッディング**手法を採用しています。これにより従来のEVM実装に比べ分岐やスタック操作のオーバーヘッドを削減し、スマートコントラクト実行を効率化します。evmoneはEVMCインタフェースに準拠しているため、プラグインとしてGethに組み込んで利用でき、Ethereumクライアントの実行性能を強化する選択肢の1つとなっています。

- revm: revmはRustで実装されたシンプルかつ高速なEVM実装です。Paradigm社が主導するRust製クライアント「Reth」で採用されています ([Awesome Ethereum Rust repos - GitHub](https://github.com/Vid201/awesome-ethereum-rust))。Rustのパフォーマンスと安全性を活かしつつ、モジュール化された設計で拡張や組み込みが容易になっているのが特徴です。Paradigmの報告によれば、revmは既存のEVMと比較して高い柔軟性と速度を実現しており、実際にRethクライアント上でチェイン同期が問題なく行えます。 ([Releasing Revmc - Paradigm](https://www.paradigm.xyz/2024/06/revmc))。さらにParadigmはrevmをベースにネイティブコードへのコンパイラである**revmc**を開発し、EVMバイトコードを直接マシン語に変換するアプローチも進めています。

### JIT/AOTコンパイルによるパフォーマンス向上

EVMの実行を高速化するもう1つの手法が、バイトコードをネイティブな機械語に**コンパイル**してしまうことです。従来のEVMはスタックマシン上でバイトコードを逐次解釈（インタプリタ実行）しますが、この方法だと命令ごとに解釈コストがかかり効率的ではありません。そこで近年注目されているのが、JIT（Just-In-Time）コンパイルやAOT（Ahead-Of-Time）コンパイルといった技術をEVMに適用することです。**JITコンパイル**は実行時にバイトコードをネイティブコードに変換し、その場で実行してしまう方式で、JavaのJVMやWebAssemblyランタイムで実績があります。 ([Reth’s path to 1 gigagas per second, and beyond - Paradigm](https://www.paradigm.xyz/2024/04/reth-perf))。一方、**AOTコンパイル**は事前にバイトコードをコンパイルしてネイティブコードを用意しておく方式で、実行時のオーバーヘッドが更に小さいという利点があります。

Paradigm社の開発したrevmcは、このAOTコンパイルをEVMに導入する先駆的な試みです。彼らの発表によれば、revmcを用いることでEVMの実行速度がケースによっては1.85倍から最大19倍にも向上することがベンチマークで示されています。revmcはEVMバイトコードを中間表現(IR)に変換して最適化を行った後、LLVMを利用してネイティブコードを生成します。こうしたAOTコンパイルにより、従来のインタプリタ実行に伴う大きなオーバーヘッドを排除し、ハードウェア上で直接コードを実行できるため大幅な性能改善が可能になります。

またAOT方式にはセキュリティ上の利点もあります。JITコンパイルは実行中に動的にコード生成をするため、悪意のあるコードにJITプロセス自体を悪用されるリスクがあります。これに対して、AOTであらかじめ信頼できるコードに変換・検証しておけばそのようなリスクを低減できます。実際、Rethクライアントでは特に利用頻度の高いコントラクトを事前コンパイルしてキャッシュすることで、都度JITする必要をなくしつつ安全性も確保する設計を計画しています。このように、JIT/AOTコンパイル技術の導入はEVMのスループット向上における新しい取り組みであり、今後レイヤー2など計算負荷の高い環境でその効果を発揮していくと期待されています。

### EthereumクライアントにおけるEVM実装の比較と最適化戦略

Ethereumはマルチクライアント主義を採用しています。Goで実装された**Geth**、Rustの**Reth**、Javaの**Besu**、C#の**Nethermind**、C++の**Erigon**など複数の実行クライアントが存在します。 ([How will Ethereum's multi-client philosophy interact with ZK-EVMs?](https://vitalik.eth.limo/general/2023/03/31/zkmulticlient.html))。各クライアントは異なる言語やアーキテクチャで実装されていますが、それぞれ独自のEVM最適化戦略を持っています。

- Geth（Go実装）は最も普及しているクライアントで、安定性重視のシンプルなインタプリタEVMを搭載しています。ただしGo言語の特性上、低レベル最適化には限界があるため、前述のevmoneプラグインを利用してC++による高速EVMに置き換えるといった拡張も可能です。

- Erigon（旧Turbo-Geth、C++/Go併用）はデータベースアクセスの効率化や並行処理によって高速化を追求したクライアントです。EVM自体の高速化というよりは、トランザクション実行前後の状態データ処理（トライ木の更新など）を最適化する戦略を取っています。

- Reth（Rust実装）は新興のクライアントで、モジュールの非同期処理による並列化や、revmおよびrevmcによるEVMのネイティブコンパイルで1ギガガス/秒の処理能力を目指しています。これは現在のEthereumが約100メガガス/秒程度であることを踏まえると10倍のスループット向上に相当します。

このように各クライアント実装が異なるアプローチでEVM性能を引き上げようとしており、将来的にどのブロックチェインもネイティブコンパイルされた高速ランタイムを備えるだろうと言われています。複数のクライアントが競い合うことでEthereum全体としての性能と安全性が高まっています。

## Ethereumの今後の進化

### EVM Object Format (EOF) とその意義

**EVM Object Format (EOF)** は、スマートコントラクトのバイトコード構造を改良するために提案された一連のEIP群からなる新しいフォーマットです。 ([EVM Object Format: EOF](org))。従来、EVMバイトコードには明確な構造やバージョン情報が無く、各クライアントはデプロイ時にコード全体を走査してJUMP先の検出・検証をする必要がありました。このため毎回のコード実行時にオーバーヘッドが生じ、新しい命令の追加や古い機能の廃止も困難でした。 ([A Complete Guide to EVM Object Format (EIP-7692)](https://blog.tenderly.co/guide-to-evm-object-format-eip-7692))。EOFはこの問題を解決するために**コンテナ形式**のバイトコードを導入し、冒頭にバージョン識別子やセクションヘッダを持たせることで、コードの検証・解釈を体系化します。具体的には、バイトコードの先頭バイトとして予約値 `0xEF` を配置し既存のどのコントラクトとも被らないシーケンス`0xEF00`がEOF識別子となります。その後にバージョン番号とコードセクション・データセクションの長さなどのヘッダ情報が続きます。EIP-3540ではこの基本フォーマットが定義され、EIP-4750では同一コントラクト内で関数呼び出しやリターンを行う新たな命令の追加が提案されています。

EOFの意義は多岐にわたります。まず、コントラクトの**バージョン管理**が可能になるため、将来的にEVMに大きな仕様変更を加える際も古いコードとの互換性を保ちつつ新機能を導入しやすくなります。またコードに明確な区切り（セクション）ができることで、不要な命令やデータ領域を実行時にスキップしやすくなり、実行効率も向上します。ジャンプ先の検証などもデプロイ時に一度行っておけば済むため、実行時の毎回の検証コストを削減できます。

### eWASM (Ethereum WebAssembly) と EVMの未来

**eWASM**（Ethereum WebAssembly）は、Ethereumのバイトコード実行環境をWebAssembly(WASM)ベースに置き換える提案です。WebAssemblyはブラウザ等で利用されている高速で移植性の高い仮想マシン仕様で、C/C++やRustなど様々な言語からコンパイル可能な汎用プラットフォームです。EthereumがeWASMを採用すると、Solidity以外の言語（例えばRustやC++）からスマートコントラクトを直接記述・コンパイルできるようになります。

元々eWASMはEthereum 2.0のフェーズ2にて導入予定とされていました。当時の計画では、シャーディング実装時に各シャードの実行環境としてEVMに代えてWASMベースのVMを採用し、EVMとの後方互換性はeWASM上でEVMバイトコードを実行できるようにする構想でした。しかしその後Ethereumのロードマップは大きく変更され、Eth1とEth2の統合（The Merge）により現在は引き続きEVMが実行環境として使われています。

もっとも、eWASMのアイデアがなくなったわけではありません。レイヤー2や他のブロックチェインプロジェクトでは、WASMをスマートコントラクトVMとして採用する例が増えてきています。現時点ではEthereumの進化はEVMの改良（EOFなど）やレイヤー2の活用によるスケーリングにフォーカスしており、eWASMは中長期的な選択肢として研究が続けられている状況です。

### Ethereum 2.0（統合後）の展望と新技術の統合可能性

EthereumはThe Mergeによってプルーフ・オブ・ステークへの移行とEth1/Eth2統合を果たしました。今後は「Surge（シャーディング）」「Verge（Verkleトライによる状態効率化）」「Purge（履歴データの削減）」「Splurge」といったロードマップが示されています。これらの中で、EVM自体の刷新や大幅な変更は主要なテーマには挙がっていません。しかし、**マルチクライアント哲学と新技術の融合**という観点では、将来的にEVM以外の実行エンジンや検証手段が「第3のクライアント」として役割を持つ可能性があります。([How will Ethereum's multi-client philosophy interact with ZK-EVMs?](https://vitalik.eth.limo/general/2023/03/31/zkmulticlient.html))。

## レイヤー2技術とEVM互換チェイン

### Optimistic Rollup と zk-Rollup の違い

レイヤー2の代表的手法である**Optimistic Rollup**（楽観的ロールアップ）と**zk-Rollup**（ゼロ知識ロールアップ）は、トランザクション検証の方法が大きく異なります。

- **Optimistic Rollup**は「全てのトランザクションは基本的に正しい（不正はまれ）」と楽観的に仮定して処理をオフチェインで行い、後から不正があれば指摘（チャレンジ）する方式です。具体的には、ロールアップ上でまとめられた取引データをそのままレイヤー1に投稿し、一旦レイヤー1上では有効と見なします。しかし一定期間（例えば1週間程度）の**チャレンジ期間**が設けられており、その間に誰でもロールアップの結果に異議を唱えることができます。不正を発見した参加者は**フロードプルーフ（詐欺証明）**と呼ばれる検証をします。不正が確認されればロールアップのその出力を無効化し、悪意ある提案者を経済的に罰する仕組みになっています。([Optimistic vs Zero-Knowledge Rollups: Which is best?](https://blog.thirdweb.com/optimistic-rollups-vs-zero-knowledge-zk-rollups/))。このモデルでは「1人でも正直な検証者がいれば不正は最終的に暴かれる」という前提で安全性を担保しており、全てを証明するzk方式に比べて計算コストが低く実装も容易という利点があります。一方で、最終的に資金を引き出すまでにチャレンジ期間の分だけ時間がかかる（典型的には1週間程度ユーザー資金がロックされる）という欠点があります。

- **zk-Rollup**は全てのトランザクション結果について**有効性証明（バリディティプルーフ）**を生成し、それをレイヤー1で検証させる方式です。各ロールアップブロックごとにZK-SNARKやZK-STARKによる証明が作られ、レイヤー1はその暗号学的証明をチェックすることでロールアップ内の全取引が正しく行われたことを保証します。この方式では不正な状態更新は承認されないため、チャレンジ期間を設ける必要がなく、ユーザーはロールアップから即座に資金を引き出すことができます。セキュリティも数理的に保証されており、信頼するのは証明を生成する回路の正当性だけで、人間の監視者に依存しません。欠点は、証明の生成に高度な計算を要する点と、検証も多少のオンチェイン計算コストがかかる点です。しかし技術の進歩により証明生成はだいぶ高速になってきており、徐々に実用段階に入っています。
また、zkロールアップは付随的に**プライバシー**を高めることも可能です。取引内容に関する詳細（例えばユーザーのアドレスや取引額）を生成者以外には秘匿しつつ、正当性だけを示すことができるため、希望すればL2上で匿名性を実現できます。

要約すると、Optimistic Rollupは**「楽観＆事後チェック」**、zk-Rollupは**「事前に厳格チェック」**のアプローチと言えます。前者は実装が簡単で当初のスループット向上には有利ですが、最終性（ファイナリティ）が遅延しうる点と、常に監視者の存在を仮定する点でトレードオフがあります。両者の手法はEthereumのスケーラビリティ問題に対する有力な解決策であり、現在はoptimistic方式が先行する一方で、zk方式も実用化が進みつつあります。

### Arbitrum, Optimism, StarkNet, zkSync などの比較

代表的なレイヤー2プロジェクトとして、Optimistic Rollup系の**Arbitrum**と**Optimism**、そしてzk-Rollup系の**StarkNet**と**zkSync** が挙げられます。それぞれEVM互換性の確保方法や設計哲学に違いがあります。

- Optimism: OptimismはOptimistic Rollupのプロジェクトで、初期は独自の仮想マシンレイヤーを用いていましたが、現在はEVMと等価な環境を実現しています。([Optimism vs Arbitrum: Comparing Layer 2 Scaling Solutions](https://coinpaper.com/3102/optimism-vs-arbitrum-comparing-layer-2-scaling-solutions))。Optimismの技術的特徴として、**シングルラウンドのfraud-proof（Fault Proof）**方式を採用している点が挙げられます。不正検証の際、一度のオンチェイン実行で成否を判定するシンプルな仕組みで、設計を簡素化する代わりに不正時のガス消費が大きくなります。実際Optimismチームは2021年末のアップデートで一時fraud-proofを無効化しつつEVM互換性の向上（OVM特有のルール撤廃）を優先しました。([Optimism & Arbitrum: Tracking Decentralization Progress - Galaxy](https://www.galaxy.com/insights/research/optimism-arbitrum-pt2-decentralization/))。ユーザーから見ると、Optimism上でのDApp利用体験はメインネットEthereumとほとんど変わらず、トランザクション手数料が安く高速なEthereumといった感覚で利用できます。

- Arbitrum: ArbitrumもOptimistic Rollupの1つで、技術的には**マルチラウンドのfraud-proof**を実装している点が特徴です。不正が疑われた際に、疑わしいトランザクションの実行をバイナリサーチのように細かく分割し、何ステップ目で食い違いがあるかを特定する対話的なプロトコルによって効率的に不正検証をします。この方式により、一度の検証あたりのオンチェイン実行コストを抑え、全体として低ガスでの不正検出を可能にしています。その代わりに最終確定までに複数回の応酬が必要なため、結果としてファイナリティ時間は若干延びます。Arbitrumは2022年にNitroアップグレードを行い、EVM互換性とスループットを向上させました。現在では開発者にとってほぼ通常のEVMと同じ感覚でコントラクトをデプロイでき、Optimismと並んで主要なRollupの一角を占めています。エコシステム面でもArbitrumはTVLでOptimismを上回るなど好調で、独自トークンを発行して分散型ガバナンスを開始するなどコミュニティも活発です。

- StarkNet: 前述の通りStarkNetはStarkWare社によるzk-Rollupで、**EVM互換性を持たない独自路線**を進んでいます。トランザクションの有効性はZK-STARKで証明され、レイヤー1に定期的に有効性証明を投稿しています。開発者体験はEthereumとは大きく異なり、SolidityではなくCairoという専用言語を用いてスマートコントラクトを書く必要があります。当初はSolidityコードをCairoに変換するWarpプロジェクトもありましたが、現在は廃止されCairoネイティブでのエコシステム構築に舵が切られています。このためEthereumの既存開発者コミュニティとは隔たりがありますが、逆に言えばEVMの制約に縛られない自由な設計が可能で、より高度な機能実装や性能チューニングが期待できます。事実、StarkNetはアカウント抽象化（Account Abstraction）を最初から組み込んでおり、ユーザビリティや機能面で先進的な試みをいくつも実現しています。

- zkSync: zkSyncはMatter Labs社によるzk-Rollupプロジェクトで、Ethereumと親和性の高いアプローチを採っています。最新のバージョンである**zkSync Era**では、SolidityやVyperで記述したコントラクトをそのままデプロイ可能で、一見EVM互換のように見えます。しかし内部的には**zkEVMではなく独自のzkVM**を用いており、Solidityのコードは一旦通常のEVMバイトコードにコンパイルされた後、さらにzkSync用のバイトコードに変換されて実行されます。 ([zkEVM solution: zkSync, StarkNet, Polygon zkEVM, Scroll - BlockBeats](https://en.theblockbeats.news/news/36080))。このためEthereumのほとんどのプログラムが動作します。zkSyncはプルーフにZK-SNARKを使用しており、迅速なファイナリティと引き出しを実現しています。また、データ圧縮やアカウント抽象化を導入することでL2手数料の削減にも取り組んでいます。

### Layer2 の EVM互換性の仕組み

多くのレイヤー2がユーザー獲得のために重視しているのが**EVM互換性**です。EVM互換性とは、SolidityやVyperで書かれた既存のスマートコントラクトやツール群（TruffleやHardhat、MetaMask等）をそのまま利用できる互換性を指します。互換性の確保方法はプロジェクトによって異なりますが、大きく分けて「EVMをそのままL2上で動かす」か「Solidityコードを別VM向けに変換して動かす」かの二通りがあります。

OptimismやArbitrumでは前者の方式を採っており、L2上にEthereumと同等のEVM実行環境（状態遷移やガス計算のルールも同一）を実装しています。そのため、Solidityで書かれコンパイルされたバイトコードを特別な変更なしにL2へデプロイでき、メタマスク等からの取引送信も通常のEthereumと同じ要領で行えます。まさに「EVMをそのまま拡張した」ような環境であり、これを指して**EVM Equivalence（EVM同等性）**と呼ぶこともあります。例えばOptimismはガス計算など一部異なっていたOVMを廃止し、現在はGeth相当のクライアント上でEVMバイトコードを実行しています。またArbitrumもNitro以降、内部でWASMに変換して実行しているものの、表面上の挙動はEVMと一致するようになりました。

一方、**StarkNetやzkSync**では後者の方式を採用しています。すなわち、Solidityで書いたコードを一旦通常のEVMバイトコードにコンパイルし、さらにそれを各プロジェクト独自のVM向けバイトコードにトランスパイルして実行します。zkSyncではEthereumのOpcodeをエミュレートするカスタムVM上で動かし、StarkNetではCairo VM上で動くように高水準言語レベルで互換性を持たせるアプローチでした。このような方式では、一部Ethereum特有の機能（プリコンパイルされた暗号関数やガスコストの差異など）に違いが生じる可能性はあります。例えば、あるSolidityコントラクトがEthereumでは動作しても、StarkNet用に書き直した場合は細かな挙動が異なる、といったケースも起こりえます。しかし多くの標準的なアプリケーションについては支障なく動作するよう設計されており、実質的にSolidityでL2開発が行える利便性を提供しています。

**何故EVM互換性が重要か** それはEthereumが長年培ってきた膨大な開発者コミュニティとツールエコシステムをそのまま活用できるからです。新しいL1ブロックチェインを一から作っても、開発言語が独自だったりツールが未整備だと開発者はなかなか移行しません。その点、L2がEVM互換であればEthereumの実績ある「バトルテスト済み」のツール群（フレームワーク等）をすぐ使え、ユーザーも既存のウォレットで簡単にアクセスできます。

もっとも、互換性と性能・機能はトレードオフになる場合もあります。StarkNetのように敢えて非互換路線を取ることで、Ethereumでは難しい新機能を実現できる利点もあります。最終的には、互換性重視のL2と独自路線のL2が併存し、それぞれの強みを発揮してEthereum全体のスケーラビリティを支える構図となっています。いずれにせよ、**EVM互換チェイン**という言葉が示す通り、EthereumのDNAを受け継ぎつつ拡張するレイヤー2技術は今後も進化と普及が見込まれます。

## スマートコントラクトのセキュリティとフォーマル検証

### Solidityスマートコントラクトの代表的な脆弱性

スマートコントラクト開発においては、従来のソフトウェア以上にセキュリティへの注意が求められます。Solidityで知られている典型的な脆弱性には以下のようなものがあります。

- 再入可能性（Reentrancy）: 再入可能性とは、コントラクトが外部に対して送金や他のコントラクトを呼び出した際に、呼び出し先から自分自身を再度呼び出されてしまう問題です。([Reentrancy Attacks in Solidity Smart Contracts: Full Guide - Cyfrin](https://www.cyfrin.io/blog/what-is-a-reentrancy-attack-solidity-smart-contracts))。例えば出金関数で残高をチェックしてから送金する場合、攻撃者コントラクトがフォールバック関数で被害コントラクトの出金関数を再度呼び出すことで、残高が減算される前に出金処理を繰り返し実行させます。結果として、攻撃者は本来1回しか引き出せないはずの資金を何度も引き出して奪うことができてしまいます。対策としては、**チェック-エフェクト-相互作用パターン**を徹底する、もしくは`ReentrancyGuard`のようなロックを用いるなどして、再入呼び出しを受け付けないように実装します。またSolidity 0.8以降ではデフォルトで`send`/`transfer`がガス制限のため推奨されなくなり、再入保護については開発者の責任に委ねられる部分が増えたため、注意が必要です。

- 署名不備・不正な署名検証: オフチェインでユーザーからの署名を受け取り、それをコントラクト内で`ecrecover`等によって検証するケースでしばしば問題が起こります。典型的なのは**署名の再利用（リプレイ）攻撃**です。 ([Signature-related Attacks - Smart Contract Security Field Guide](https://scsfg.io/hackers/signature-attacks/))。コントラクトが一度受け付けた署名付きメッセージを何度でも有効にしてしまうと、攻撃者は同じ署名を使い回して複数回処理を実行させることができます。例えば所有者の署名に基づき資金送金するコントラクトで、署名ごとに一度しか使えないようなnonceやフラグの管理をしていない。この場合、攻撃者は1つの署名をコピーして何度も送金関数を呼び出し資金を引き出すことが可能になります。また`ecrecover`の戻り値に対する**チェック不足**もよくある問題です。ecrecoverは無効な署名パラメータが与えられた場合に`0x0`（nullアドレス）を返す可能性があります。これを正しく検出せず進めてしまうと、攻撃者は細工した署名で`ecrecover`を失敗させつつ常に`address(0)`を返させ、コントラクト側がそれを有効な署名だと誤認するケースがあります。対策としては、署名検証後に戻り値アドレスが期待する署名者か確認し、不正時は必ず処理を中断する。署名メッセージにはユニークなnonceやドメイン区分（EIP-712など）を含めて**一度きり**かつ**別文脈で使えない**ようにすることが重要です。

この他にもSolidity特有の脆弱性として、整数オーバーフロー・アンダーフロー、`tx.origin`を用いた認証。デリゲートコールの誤用による権限奪取。自己宛送金（`selfdestruct`）による残高強制送金。乱数の予測可能性などがあります。開発者は常に最新のベストプラクティスと過去事例を学び、脆弱性を埋め込まないよう注意深くコントラクトを実装・テストします。

### セキュリティツールの紹介 (Slither, MythX, SMTソルバー)

スマートコントラクトの脆弱性を低減するため、開発・監査段階で利用できる様々なセキュリティツールが提供されています。その中でも代表的なものが **Slither**、**MythX**（Mythril）と**SMTソルバー/形式手法**です。

- Slither: Trail of Bits社が開発したSolidityコード用の静的解析ツールです。Pythonで書かれています。コントラクトのAST（抽象構文木）を解析しながら数多くの既知の脆弱性パターンを検出します。例えば、再入可能性の可能性があるパターンや外部呼出し後に状態更新しているコード。ガスの無限消費になりかねないループ。未使用変数や冗長なコード。など、多岐にわたるチェックを一瞬で行ってくれます ([The Top 10 Solidity Smart Contract Audit Tools](https://blog.auditbase.com/smart-contract-audit-tools))。出力も分かりやすく、問題箇所と種類を報告してくれるため、開発者自ら脆弱性を洗い出すのにも適しています。Slitherはコマンドラインで簡単に使え、CIに組み込んでコントラクトの品質ゲートとできます。

- MythX / Mythril: MythXはSolidityコード向けの包括的なセキュリティ分析プラットフォームです。そのエンジン部分はオープンソースの**Mythril**で、これは**動的解析（シンボリック実行）**と**SMTソルバー**、**ティント解析**を組み合わせてスマートコントラクトの深いバグを探し出します。([MythX, Mythril, Securify v2.0 and Slither - Dreamlab Technologies](https://dreamlab.net/es/blog/entrada/smarts-contracts-security-tools-comparison-mythx-mythril-securify-v20-and-slither-1/))。静的解析のSlitherでは検出しにくい、複数のコントラクト間の相互作用に起因するバグ。特定の入力の組み合わせでのみ発生するような複雑な脆弱性。これらも、Mythrilのシンボリック実行によって網羅的にテストされることで発見できます。MythXは有料サービスとしてクラウド上でMythril分析を提供しており、大規模プロジェクトの自動監査に使われています。例えば、関数の引数に巧妙な値を入れた場合にのみ起こる整数の不正。署名検証ロジックの抜け道。人間の目では見落としがちなケースも検出可能です。ただしシンボリック実行は計算コストが高く、解析に時間がかかる点には注意が必要です。

- SMTソルバーとフォーマル検証ツール: さらに高度な手法として、**形式手法（フォーマルメソッド）**を用いた検証があります。Solidity公式コンパイラにはSMTCheckerと呼ばれるモジュールが搭載されており、コントラクトの`assert`や`require`で記述した性質を自動的に検証する機能があります。([SMTChecker and Formal Verification](https://docs.soliditylang.org/tr/latest/smtchecker.html))。SMTCheckerはコントラクトを論理数式に置き換えて、モデル検査をすることでコードが特定の条件を常に満たすかをチェックします。例えば「オーバーフローが起こらないこと」や「ある不変条件が常に成り立つこと」を証明しようと試み、もし違反があれば具体的な入力値の例を出力して警告してくれます。内部ではZ3などのSMTソルバーが動いており、有限の範囲内ではありますが自動で数学的な検証をします。他にも、CertoraやVeriSol、KEVM、DappHub社のhevmによる形式検証スクリプト。など、様々なフォーマル検証ツールが存在します。学習コストは高いものの、コントラクトの安全性を機械的に保証する強力な手段となります。

### フォーマル検証（Formal Verification）による安全性向上

フォーマル検証とは、プログラムが仕様を満たしていることを数学的に証明する手法です。スマートコントラクトの場合、「仕様」とは例えば「常に口座残高の総和は一定である」や「この関数を呼ぶと必ず状態Aから状態Bに遷移する」といった形式化された要件になります。フォーマル検証ではコントラクトコードと仕様を論理的なモデルに落とし込み、あらゆる入力に対してその仕様が破られないことを証明します。もし証明できない場合、反例となる入力（バグを引き起こすシナリオ）を出力することで、開発者は潜在的な欠陥を正確に把握できます。

フォーマル検証の利点は、テストや手動のコードレビューでは見逃すような極端なケースや並行実行のタイミング依存のバグなども洗い出せる点にあります。特にDeFiのように資産を扱うコントラクトでは、一度デプロイするとアップグレードや修正が容易でないため、事前にバグが無いことを保証する意義は大きいです。例えばMakerDAOのDaiコントラクトや、一部のマルチシグウォレット、ETH2の預け入れコントラクトなどはフォーマル検証技術によってその正当性が確認されています。実際、Ethereum 2.0のDepositコントラクトは形式手法専門の企業Runtime Verificationによって検証されました。CompoundやUniswapの一部についても不変条件の証明が試みられています。

もっともフォーマル検証にも限界や注意点があります。仕様そのものが間違っていれば意味がありませんし、人間が理解できない仕様を書いても本末転倒です。また、スマートコントラクトは外部との相互作用があるため、検証範囲をシステム全体に広げるのは困難です。それでも、スマートコントラクトの重要な性質（「絶対にオーバーフローしない」や「利率計算が常に期待通り」など）を機械的に保証できるのは大きな強みです。

開発実務においては、まずSlitherのような静的解析と十分なユニットテストで一般的なバグをなくし、MythXやSMTCheckerでより深い検証を進めます。そして最終的なプロトコル全体の安全性については、専門家によるフォーマル検証や継続的な監視で担保する多層防御が理想的です。

スマートコントラクトのバグは直接金銭被害に繋がります。そのリスクを最小化するため、これら最新のセキュリティ手法を習得し活用していくことが重要でしょう。
