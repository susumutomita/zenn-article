---
title: "Solidityスマートコントラクトを自作EVM上で実行する"
free: true
---

## はじめに

この章では、Solidityで書いたスマートコントラクトを作成したEVMで実行してみます。

## サンプルコントラクト実行の流れ

SimpleAdder.solのようなシンプルなSolidityコントラクトをEVMで実行する基本的な流れは次のとおりです。

- コントラクトのコンパイル: SolidityコードをEVMバイトコードにコンパイル
- バイトコードの解析: バイトコードを読み込み、実行可能な形式に変換
- 実行コンテキストの準備: 関数呼び出しに必要なcalldataの作成
- EVM実行: バイトコードをステップバイステップで実行
- 結果の取得: returndataを取得して結果を解釈

### 簡易EVMでの実行

Zig側で、コンパイルして得たバイトコードと、関数呼び出しの入力データを用意し、`run`関数に渡します。一般にコントラクトの関数を呼び出す際、EVMに与える入力データ（call data）は以下のように構成されます。

- 最初の4バイト: 呼び出す関数を表す**関数セレクタ**（関数識別子）。関数名と引数型から計算される固定の識別子です。
- 残り: 各引数の値を32バイトにエンコードしたものを順番に並べたもの。

今回の`add(uint256,uint256)`関数の場合、関数セレクタは`"add(uint256,uint256)"`という文字列のKeccak-256ハッシュの先頭4バイトで決まります。計算すると`0x771602f7`という値になります。続いて、例えば引数`a = 10`、`b = 32`を与えたい場合、それぞれ32バイトにパディングされた表現を付加します。10は16進で`0x0a`、32は`0x20`ですので、32バイト表現ではそれぞれ`0x000...00a`（最後の1バイトが0×0a）と`0x000...020`になります。つまり、呼び出しデータ全体を16進で表すと次のようになります。

```bash
0x771602f7 000000000000000000000000000000000000000000000000000000000000000a
0000000000000000000000000000000000000000000000000000000000000020
```

（スペースは見やすさのため。実際には詰めて68バイトのデータ）。このデータを我々の`run`関数に渡せば、関数`add(10,32)`を実行したのと同じ効果が得られるはずです。

では、Zigの`main`関数内で具体的に実行してみます。Zigでの16進データの扱いとして、ここでは簡単のため入力データをバイト配列リテラルとして直接埋め込んでいます。先ほどのバイトコードもコピーしてバイト列として渡します。

```zig
pub fn main() !void {
    const bytecode = &[_]u8{
        // ここにAdderコントラクトのバイトコードを16進で並べる（長いため省略）
        0x60,0x80,0x60,0x40,0x52,0x34,0x80,0x15,0x60,0x0f,0x57,0x60,0x00,0x80,0xfd,0x5b,
        0x50,0x60,0x15,0x00,0x56,0xfe,0xa2,0x64,0x69,0x70,0x66,0x73,0x58,0x22,0x12,0x20,
        // （中略: 実際にはバイトコード全体をここに貼り付け）
    };
    const input_data = &[_]u8{
        // 関数セレクタ 0x771602f7
        0x77, 0x16, 0x02, 0xf7,
        // 引数a=10の32バイト表現（31バイトの0の後に0x0a）
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,
        // 引数b=32の32バイト表現（31バイトの0の後に0x20）
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
        0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,
    };

    const result = run(bytecode, input_data);

    // 結果を16進数で出力
    std.debug.print("Return data (hex): ", .{});
    for (result) |byte| {
        std.debug.print("{02x}", .{byte});
    }
    std.debug.print("\n", .{});
}
```

上記の`main`では、`bytecode`にコンパイルして得たAdderコントラクトのバイトコード（ランタイム部分も含む）をバイト列として定義しています。次に`input_data`を、先ほど説明した関数セレクタ＋引数の形式で構築しています。そして`run(bytecode, input_data)`を呼び出し、その戻り値（バイト列）を取得しています。

最後に、その`result`バイト列を16進で出力しています。EVM上の関数戻り値は32バイト長のデータ（今回なら計算結果の整数を32バイトにエンコードしたもの）なので、それをそのまま表示する形です。

ではこのプログラムをビルド・実行してみましょう。Zigファイルを`evm_main.zig`とすると、以下のようにコンパイル＆実行します。

```bash
$ zig build-exe evm_main.zig
$ ./evm_main
Return data (hex): 000000000000000000000000000000000000000000000000000000000000002a
```

出力された`Return data`がずらっと並ぶ0と`2a`という値になっていることがわかります。`0x2a`は10進数で42に相当します。元の関数呼び出しは`add(10, 32)`でしたので、戻り値が42となっているのは正しい結果です 🎉。

このようにして、Solidityで書いたスマートコントラクト（の一部機能）を、実装したEVMエンジン上で実行できました。もちろん、実際のEthereumノードが行っている処理のごく一部を真似ただけですが、EVMバイトコードの動作原理が体験できたました。

## EVMの拡張と発展的な話題

### zkEVMとEVMの進化

近年注目されている技術トピックとして**zkEVM**があります。zkEVMとは、**Zero-Knowledge Proof（ゼロ知識証明）**を統合したEVM互換の実行環境のことです。 [Kakarot zkEVM の詳細解説：Starknet の EVM 互換の道 - ChainCatcher](https://www.chaincatcher.com/ja/article/2097197)。具体的には、通常は全ノードがEVMを実行してトランザクションを検証するところを、EVMの実行プロセス自体を暗号学的証明（有効性証明）によって保証しようという試みで。これにより、ブロックチェイン上の全検証者が逐一EVM計算を再現しなくても、証明を検証するだけで正しい結果であることを確認できるようになります。

zkEVMは主にLayer2（レイヤー2）のスケーリングソリューションとして期待されています。代表的なプロジェクトにPolygon zkEVMやScroll、StarkWareの**Kakarot**などがあります。例えばKakarotはStarknet上にCairo言語で実装されたEVM互換機です。CairoスマートコントラクトとしてEVMのスタックやメモリ、命令実行をシミュレートするものになっています。zkEVMによってLayer2上でEVMをそのまま動かしつつ、各トランザクションの有効性をロールアップします。そうすることで、Ethereumメインネットよりも高速・安価な処理を実現できます。

Ethereum自体の進化という点では、**イスタンブール**や**ロンドン**といったハードフォークでEVMのガスコスト調整や新命令の追加が行われてきました。直近では`RETURNDATA`系命令の導入や`CREATE2`命令の追加などがありました。また将来的な提案として、EVMのバイトコードフォーマットを改良する**EVM Object Format (EOF)**や、高レベル命令セットへの置き換えなどもあります。しかし互換性の問題から、EthereumメインネットのEVMは慎重にアップグレードが進められています。現在はEthereum2.0移行に伴いコンセンサス層が大きく変わりましたが、実行層としてのEVMは従来の仕組みを維持しています。その意味で、EVMは依然としてEthereumエコシステムの根幹であり続けています。

### おわりに

本記事では、Zig言語を使ってEVMの簡易実装に挑戦し、Solidityスマートコントラクトの実行を確認しました。EVMの仕組み（スタックマシン、バイトコード、ガスモデルなど）を低レベルから体験することで、Solidityを書くときにもその裏側で何が行われているのかイメージできるようになったのではないでしょうか。
