# イーサリアムにおけるトランザクション処理の仕組み

## 1. トランザクションの流れ

**トランザクションのデータ構造:** イーサリアムのトランザクションは、以下のようなフィールドで構成されています ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E3%83%90%E3%83%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%81%B8%E3%81%AE%E3%83%81%E3%83%83%E3%83%97%E3%81%A8%E3%81%97%E3%81%A6%E5%90%AB%E3%82%81%E3%82%8B%E9%9A%9B%E3%81%AB%E6%B6%88%E8%B2%BB%E3%81%95%E3%82%8C%E3%82%8B%E3%82%AC%E3%82%B9%E4%BB%A3%E3%81%AE%E4%B8%8A%E9%99%90%E3%80%82)) ([イーサリアムのトランザクション #Blockchain - Qiita](https://qiita.com/blueplanet/items/cac334133e252b50c2b0#:~:text=,s%3A%20%E6%9A%97%E5%8F%B7%E5%8C%96%E5%91%A8%E3%82%8A%E3%81%AE%E3%83%87%E3%82%B8%E3%82%BF%E3%83%AB%E7%BD%B2%E5%90%8D%E9%96%A2%E9%80%A3))。

- **送信元 (`from`)**: 取引の送信者アドレス。トランザクションに署名する外部所有アカウント（EOA）です ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E2%80%93%20%E4%BB%BB%E6%84%8F%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%90%AB%E3%82%80%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%80%82))。署名により、このアドレスの所有者が取引を承認したことを証明します。
- **宛先 (`to`)**: 受信者のアドレス。EOAであればETHの転送になり、コントラクトアカウントであればその契約コードの実行となります ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E2%80%93%20%E4%BB%BB%E6%84%8F%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E5%90%AB%E3%82%80%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%95%E3%82%A3%E3%83%BC%E3%83%AB%E3%83%89%E3%80%82))。コントラクト作成の場合はこのフィールドは空になります。
- ** nonce (ナンス)**: 送信元アカウントがこれまでに送信したトランザクションの通算番号です ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E5%A0%B4%E5%90%88%E3%80%81%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AF%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%29%20,%E3%82%92%E5%90%AB%E3%82%80))。各トランザクションに一意の連番を与えて順序を管理し、再送（リプレイ）攻撃を防ぎます ([How Do Ethereum Transactions Work?](https://www.doubloin.com/learn/how-ethereum-transactions-work#:~:text=What%20is%20a%20Nonce%20in,Ethereum%20Transactions))。
- **値 (`value`)**: 宛先に送るETHの量（Wei単位）です ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E5%A0%B4%E5%90%88%E3%80%81%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AF%E3%82%B3%E3%83%B3%E3%83%88%E3%83%A9%E3%82%AF%E3%83%88%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%29%20,%E3%82%92%E5%90%AB%E3%82%80))。例えば`1 ETH = 1e18 Wei`となります。価値転送がない場合は0になります。
- **入力データ (`input data` or `data`)**: オプションのデータフィールド ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=%2A%20%60nonce%60%20,%E3%82%92%E5%90%AB%E3%82%80))。コントラクト呼び出し時の関数識別子やパラメータ、あるいはコントラクト作成時のバイトコードを含みます。通常のETH送金では空のままです。
- **ガス制限 (`gasLimit` or `gas`)**: このトランザクションで消費を許容する最大ガス量です ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E3%82%92%E5%90%AB%E3%82%80))。計算ステップごとに一定量のガスを消費し、上限を超えるとトランザクションは失敗（Out of Gas）します。未使用ガス分は返金されます。
- **ガス価格/手数料 (`gasPrice`, `maxFeePerGas`, `maxPriorityFeePerGas`)**: トランザクション手数料として支払うガス単価を指定します。従来型（レガシー）トランザクションでは単一の`gasPrice`をWei単位で指定し、消費ガス量との積が手数料になります。一方、**EIP-1559** 以降は動的手数料モデルが導入され、`maxFeePerGas`（支払い最大値）と`maxPriorityFeePerGas`（マイナーへのチップ）で上限を指定します ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E3%82%92%E5%90%AB%E3%82%80))。この手数料インセンティブにより、マイナー（バリデータ）はガス価格の高いトランザクションを優先して処理します ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=match%20at%20L310%20%E3%83%9E%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%AF%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%E3%81%8B%E3%82%89%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E9%81%B8%E3%81%B3%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%92%E7%94%9F%E6%88%90%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%83%9E%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%AF%E9%80%9A%E5%B8%B8%E3%80%81%E3%82%AC%E3%82%B9%E4%BE%A1%E6%A0%BC%E3%81%8C%E9%AB%98%E3%81%84%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E5%84%AA%E5%85%88%E3%81%97%E3%81%A6%E9%81%B8%E6%8A%9E%20%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%88%E3%82%8A%E5%A4%9A%E3%81%8F%E3%81%AE%E5%A0%B1%E9%85%AC%E3%82%92%E5%BE%97%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82))。
- **署名 (`signature`: *v*, *r*, *s*)**: 送信元がトランザクションを承認するためのデジタル署名です ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E6%94%AF%E6%89%95%E3%81%86%E7%94%A8%E6%84%8F%E3%81%8C%E3%81%82%E3%82%8B%E3%82%AC%E3%82%B9%E5%8D%98%E4%BD%8D%E3%81%82%E3%81%9F%E3%82%8A%E3%81%AE%E6%9C%80%E5%A4%A7%E6%89%8B%E6%95%B0%E6%96%99%28%60baseFeePerGas%20%60%E3%81%A8))。送信者の秘密鍵でトランザクション内容のハッシュに対しECDSA署名を行うことで生成され、署名要素として *r*・*s* と、公開鍵復元用の *v*（リカバリID）が含まれます ([東大生がSolidity0.8.14マニュアル読み込んでみた-Basics-｜現役東大生コウくんのsolidity日記](https://note.com/koseirving/n/n6f710238ddf5#:~:text=%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%ABECDSA%E7%BD%B2%E5%90%8D%E3%81%AFr%E3%81%A8s%E3%81%A8%E3%81%84%E3%81%862%E3%81%A4%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E6%A7%8B%E6%88%90%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82Ethereum%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%AFv%E3%81%A8%E3%81%84%E3%81%863%E3%81%A4%E7%9B%AE%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%A9%20%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E7%A7%98%E5%AF%86%E9%8D%B5%E3%81%8C%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%8B%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E3%81%9D%E3%81%AE%E5%8F%96%E5%BC%95%E3%81%AE%E9%80%81%E3%82%8A%E4%B8%BB%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Solidity%20%E3%81%AB%E3%81%AF%20%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E9%96%A2%E6%95%B0,ecrecover%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%A8%20r%E3%80%81s%E3%80%81v%20%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%94%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。ブロックチェーン上には署名の*v*,*r*,*s*が記録され、**送信元アドレス (`from`) 自体はトランザクションデータ内に明示的には含まれません**。ノードはこの署名から公開鍵を復元し、対応するアドレスを計算することで送信者を特定します ([東大生がSolidity0.8.14マニュアル読み込んでみた-Basics-｜現役東大生コウくんのsolidity日記](https://note.com/koseirving/n/n6f710238ddf5#:~:text=%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%ABECDSA%E7%BD%B2%E5%90%8D%E3%81%AFr%E3%81%A8s%E3%81%A8%E3%81%84%E3%81%862%E3%81%A4%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E6%A7%8B%E6%88%90%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82Ethereum%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%AFv%E3%81%A8%E3%81%84%E3%81%863%E3%81%A4%E7%9B%AE%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%A9%20%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E7%A7%98%E5%AF%86%E9%8D%B5%E3%81%8C%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%8B%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E3%81%9D%E3%81%AE%E5%8F%96%E5%BC%95%E3%81%AE%E9%80%81%E3%82%8A%E4%B8%BB%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Solidity%20%E3%81%AB%E3%81%AF%20%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E9%96%A2%E6%95%B0,ecrecover%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%A8%20r%E3%80%81s%E3%80%81v%20%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%94%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。

**トランザクション発行からブロック記録まで:** ユーザが上記の情報を組み立てトランザクションに署名すると、ネットワークにブロードキャストできます。例えばRPCノード（イーサリアムクライアント）のエンドポイントに対し、署名済みトランザクションを送信します。ノードは受信したトランザクションについて以下の処理を行います。

- **検証:** ノードはまずトランザクションの構文と署名を検証します。RLPデコードして各フィールドを取り出し、`v,r,s`から公開鍵を復元して送信元アドレスを算出します ([東大生がSolidity0.8.14マニュアル読み込んでみた-Basics-｜現役東大生コウくんのsolidity日記](https://note.com/koseirving/n/n6f710238ddf5#:~:text=%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%ABECDSA%E7%BD%B2%E5%90%8D%E3%81%AFr%E3%81%A8s%E3%81%A8%E3%81%84%E3%81%862%E3%81%A4%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E6%A7%8B%E6%88%90%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82Ethereum%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%AFv%E3%81%A8%E3%81%84%E3%81%863%E3%81%A4%E7%9B%AE%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%A9%20%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E7%A7%98%E5%AF%86%E9%8D%B5%E3%81%8C%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%8B%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E3%81%9D%E3%81%AE%E5%8F%96%E5%BC%95%E3%81%AE%E9%80%81%E3%82%8A%E4%B8%BB%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Solidity%20%E3%81%AB%E3%81%AF%20%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E9%96%A2%E6%95%B0,ecrecover%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%A8%20r%E3%80%81s%E3%80%81v%20%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%94%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。その上で、①署名者のアカウントが実際に宣言された`nonce`を持っているか（順序チェック）、②十分な残高がありガス費用（`gasLimit * gasPrice`）+送金額を賄えるか、③ガス価格が最低必要量を満たすか（ネットワークの最小ガス価格条件）等を確認します。検証に失敗した場合、そのトランザクションは拒否され、ネットワークに伝播されません。成功したトランザクションは**メモリプール（mempool）**に格納されます ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=match%20at%20L263%20%E6%A4%9C%E8%A8%BC%E3%81%8C%E6%88%90%E5%8A%9F%E3%81%97%E3%81%9F%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AF%20%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB,%E3%81%AB%E8%93%84%E7%A9%8D%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%20%E3%81%AF%E6%9C%AA%E5%87%A6%E7%90%86%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%BE%85%E6%A9%9F%E5%A0%B4%E6%89%80%E3%81%A7%E3%81%82%E3%82%8A%E3%80%81%E3%81%93%E3%81%93%E3%81%AB%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AB%E4%BF%9D%E7%AE%A1%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。

- **メモリプールへの格納と伝搬:** 検証済みトランザクションは各ノードのメモリプールに一時保存されます ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=match%20at%20L263%20%E6%A4%9C%E8%A8%BC%E3%81%8C%E6%88%90%E5%8A%9F%E3%81%97%E3%81%9F%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AF%20%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB,%E3%81%AB%E8%93%84%E7%A9%8D%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%20%E3%81%AF%E6%9C%AA%E5%87%A6%E7%90%86%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%BE%85%E6%A9%9F%E5%A0%B4%E6%89%80%E3%81%A7%E3%81%82%E3%82%8A%E3%80%81%E3%81%93%E3%81%93%E3%81%AB%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AB%E4%BF%9D%E7%AE%A1%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。ノードはピア間でゴシッププロトコルによりこの未処理トランザクションを互いに送り合い、ネットワーク全体に伝播させます ([How Do Ethereum Transactions Work?](https://www.doubloin.com/learn/how-ethereum-transactions-work#:~:text=Following%20this%20creation%20phase%20is,prioritize%20certain%20transactions%20over%20others))。メモリプールは未だブロックに含まれていないトランザクションの待機所であり、取引所の注文板のような役割を果たします。

- **ブロックへの取り込み（マイニング/検証）:** イーサリアムではマイナー（現在はPoSではバリデータ）が一定間隔で新しいブロックを作成します。マイナーは自分のノードのメモリプールからいくつかのトランザクションを選択してブロックにまとめます ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=match%20at%20L310%20%E3%83%9E%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%AF%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%E3%81%8B%E3%82%89%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E9%81%B8%E3%81%B3%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%92%E7%94%9F%E6%88%90%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%83%9E%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%AF%E9%80%9A%E5%B8%B8%E3%80%81%E3%82%AC%E3%82%B9%E4%BE%A1%E6%A0%BC%E3%81%8C%E9%AB%98%E3%81%84%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E5%84%AA%E5%85%88%E3%81%97%E3%81%A6%E9%81%B8%E6%8A%9E%20%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%88%E3%82%8A%E5%A4%9A%E3%81%8F%E3%81%AE%E5%A0%B1%E9%85%AC%E3%82%92%E5%BE%97%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82))。この際、手数料収入を最大化するために通常ガス価格の高い順にトランザクションが選ばれます ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=match%20at%20L310%20%E3%83%9E%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%AF%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%E3%81%8B%E3%82%89%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E9%81%B8%E3%81%B3%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%92%E7%94%9F%E6%88%90%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%83%9E%E3%82%A4%E3%83%8A%E3%83%BC%E3%81%AF%E9%80%9A%E5%B8%B8%E3%80%81%E3%82%AC%E3%82%B9%E4%BE%A1%E6%A0%BC%E3%81%8C%E9%AB%98%E3%81%84%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E5%84%AA%E5%85%88%E3%81%97%E3%81%A6%E9%81%B8%E6%8A%9E%20%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%82%88%E3%82%8A%E5%A4%9A%E3%81%8F%E3%81%AE%E5%A0%B1%E9%85%AC%E3%82%92%E5%BE%97%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82))。選ばれたトランザクションはブロックに追加される前にEVM上で順次実行され、各トランザクションによる状態変更（アカウント残高の増減やコントラクトの状態更新）が適用されます。各トランザクション処理後にはガスが消費され、万一ガス不足や実行失敗（例: require条件不成立）が発生した場合、そのトランザクションはブロック内で **失敗** とマークされ（状態は巻き戻されますが消費したガスは戻りません）、次のトランザクションへと処理が進みます。すべてのトランザクションを適用し終えると、そのブロックの**トランザクションルートハッシュ**と**レシートルートハッシュ**が計算され、ブロックヘッダに記録されます ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%AE%E5%85%A8%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%A7%E3%81%99%E3%80%82%E5%90%84%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%AF%E3%80%81%E9%80%81%E4%BF%A1%E5%85%83%E3%80%81%E9%80%81%E4%BF%A1%E5%85%88%E3%80%81%E9%80%81%E4%BF%A1%E9%A1%8D%E3%80%81%E3%82%AC%E3%82%B9%E4%BE%A1%E6%A0%BC%E3%80%81%E3%83%8A%E3%83%B3%E3%82%B9%E3%80%81%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%20%E5%BD%B9%E5%89%B2%20%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%AD%A3%E3%81%97%E3%81%84%E3%81%8B%E3%82%92%E6%A4%9C%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%94%B9%E3%81%96%E3%82%93%E3%81%95%E3%82%8C%20%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E4%BF%9D%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Image))。トランザクションルートはブロック内全トランザクションのリストから作られたMerkle Treeのルートで、各トランザクションデータの整合性を証明します ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%AE%E5%85%A8%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%A7%E3%81%99%E3%80%82%E5%90%84%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%AF%E3%80%81%E9%80%81%E4%BF%A1%E5%85%83%E3%80%81%E9%80%81%E4%BF%A1%E5%85%88%E3%80%81%E9%80%81%E4%BF%A1%E9%A1%8D%E3%80%81%E3%82%AC%E3%82%B9%E4%BE%A1%E6%A0%BC%E3%80%81%E3%83%8A%E3%83%B3%E3%82%B9%E3%80%81%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%20%E5%BD%B9%E5%89%B2%20%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%AD%A3%E3%81%97%E3%81%84%E3%81%8B%E3%82%92%E6%A4%9C%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%94%B9%E3%81%96%E3%82%93%E3%81%95%E3%82%8C%20%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E4%BF%9D%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Image))。最終的にブロックが承認・確定すれば、その中の各トランザクションは正式にブロックチェーン上に記録され完了となります。

- **トランザクションレシート:** トランザクションがブロックに取り込まれると、各トランザクションに対して**レシート**が生成されます。レシートにはブロック番号やトランザクションインデックス、消費ガス量、実行結果のステータス（成功=1/失敗=0）、発生したイベントログ、契約作成時の新規コントラクトアドレスなどが含まれます。このレシートは`eth_getTransactionReceipt`などのRPC呼び出しで参照でき、ユーザはそれを見て自分のトランザクションが成功したか確認できます。

まとめると、トランザクションはユーザの署名によって承認された取引情報であり ([Ethereumの基本｜Ken @ インフラエンジニア](https://note.com/oh_yeahfire/n/nf3f190d394ff#:~:text=2))、ネットワーク上で検証・中継されてブロックに格納されます ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=%E6%A4%9C%E8%A8%BC%E3%81%8C%E6%88%90%E5%8A%9F%E3%81%97%E3%81%9F%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AF%20%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%20%E3%81%AB%E8%93%84%E7%A9%8D%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E3%83%A1%E3%83%A0%E3%83%97%E3%83%BC%E3%83%AB%20%E3%81%AF%E6%9C%AA%E5%87%A6%E7%90%86%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E5%BE%85%E6%A9%9F%E5%A0%B4%E6%89%80%E3%81%A7%E3%81%82%E3%82%8A%E3%80%81%E3%81%93%E3%81%93%E3%81%AB%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E4%B8%80%E6%99%82%E7%9A%84%E3%81%AB%E4%BF%9D%E7%AE%A1%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。ブロック内に記録されたトランザクションは改ざん不可能であり（ハッシュによる検証が可能） ([[Web3] もう少し踏み込んでイーサリアムを理解しよう！（第６回） - News report AI lands ](https://shion.blog/ethereum_2/#:~:text=%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%AE%E5%85%A8%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%81%A7%E3%81%99%E3%80%82%E5%90%84%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%AF%E3%80%81%E9%80%81%E4%BF%A1%E5%85%83%E3%80%81%E9%80%81%E4%BF%A1%E5%85%88%E3%80%81%E9%80%81%E4%BF%A1%E9%A1%8D%E3%80%81%E3%82%AC%E3%82%B9%E4%BE%A1%E6%A0%BC%E3%80%81%E3%83%8A%E3%83%B3%E3%82%B9%E3%80%81%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%90%AB%E3%81%BE%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%20%E5%BD%B9%E5%89%B2%20%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AB%E3%83%BC%E3%83%88%E3%83%8F%E3%83%83%E3%82%B7%E3%83%A5%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%86%85%E3%81%AE%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%AD%A3%E3%81%97%E3%81%84%E3%81%8B%E3%82%92%E6%A4%9C%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AB%E3%82%88%E3%82%8A%E3%80%81%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E6%94%B9%E3%81%96%E3%82%93%E3%81%95%E3%82%8C%20%E3%81%A6%E3%81%84%E3%81%AA%E3%81%84%E3%81%93%E3%81%A8%E3%82%92%E4%BF%9D%E8%A8%BC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Image))、その内容に従ってイーサリアムの状態（アカウント残高やコントラクトのストレージ）が更新されていきます。

## 2. JSON-RPCを用いたトランザクション送信と取得

イーサリアムクライアントはJSON-RPCインターフェースを提供しており、外部アプリケーションはこれを通じてトランザクションの送信や情報取得を行います ([How do Ethereum transactions work? - Alchemy Docs](https://docs.alchemy.com/docs/how-ethereum-transactions-work#:~:text=How%20do%20Ethereum%20transactions%20work%3F,only%20requests))。代表的なメソッドとその役割は以下の通りです。

- **`eth_sendRawTransaction`**: 署名済みトランザクションをネットワークにブロードキャストするRPCメソッドです。パラメータにRLPエンコードされた生のトランザクションデータを16進文字列で指定します ([eth_sendRawTransaction | MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=curl%20https%3A%2F%2Fmainnet.infura.io%2Fv3%2F%3CYOUR,1))。成功すると**トランザクションハッシュ**（32バイトの識別子）が返されます ([eth_sendRawTransaction | MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=Returns))。ハッシュが返ってきた時点ではトランザクションはまだブロックに含まれておらず、各ノードのメモリプールに入った状態です。例えばInfuraのRPCエンドポイントに対し、curlで以下のようなJSON-RPCリクエストを送ります ([eth_sendRawTransaction | MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=curl%20https%3A%2F%2Fmainnet.infura.io%2Fv3%2F%3CYOUR,1))。

  ```json
  {
    "jsonrpc": "2.0",
    "method": "eth_sendRawTransaction",
    "params": ["0xf869018203e8825208...83"],
    "id": 1
  }
  ```

  上記のように、`params`に署名済みトランザクションを表す長い16進文字列を渡すと、ノードはそれを受け取り前述の検証を行った上でネットワークに展開します。レスポンスは以下のようにトランザクションハッシュを返します ([eth_sendRawTransaction | MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=))。

  ```json
  {
    "id": 1,
    "jsonrpc": "2.0",
    "result": "0xe670ec6434177160...7331"
  }
  ```

  このハッシュ値を用いて後述の`eth_getTransactionReceipt`等で結果確認ができます。**注意:** このメソッドは**既に署名されたトランザクション**専用であり、ノード側では署名を行いません ([eth_sendRawTransaction | MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=Submits%20a%20pre,broadcast%20to%20the%20Ethereum%20network))。

- **`eth_sendTransaction`**: 署名されていないトランザクションオブジェクトを渡し、ノード側で署名・送信してもらうためのメソッドです。例えばパラメータに`{from: 自分のアドレス, to: 宛先アドレス, value: 金額, gas: ガス上限,...}`といったオブジェクトを指定します。これはローカルノードに自分のアカウントをアンロックして鍵を保持させている場合に使用できます。ノードは内部で該当アカウントの秘密鍵を用いて署名し、ネットワークに投入します ([web3.eth — web3.js 1.0.0 documentation](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#:~:text=Note))。返り値は`eth_sendRawTransaction`と同じくトランザクションハッシュです。一般にクラウド提供のノード（Infura等）では秘密鍵を預けることはないため、このメソッドは使われず、アプリ側で署名して`eth_sendRawTransaction`を使うケースが多いです。

- **`eth_getTransactionReceipt`**: トランザクションハッシュを指定すると、そのトランザクションのレシートを取得するメソッドです ([eth_sendRawTransaction | MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=Returns))。まだブロックに取り込まれていないペンディング状態のトランザクションに対してはレシートは存在しないため、一般にこのメソッドはトランザクションがマイニング（承認）された後に使用します ([eth_sendRawTransaction - MetaMask developer documentation](https://docs.metamask.io/services/reference/ethereum/json-rpc-methods/eth_sendrawtransaction/#:~:text=Use%20eth_getTransactionReceipt%20to%20get%20the,KEY%3E))。返されるレシートオブジェクトには、`status`（1=成功 or 0=失敗）、`blockNumber`（含まれたブロック番号）、`gasUsed`（実際消費されたガス量）、`contractAddress`（新規コントラクト生成の場合そのアドレス）、`logs`（イベントログ一覧）などの情報が含まれます ([eth_getTransactionReceipt | Ethereum - Chainstack Docs](https://docs.chainstack.com/reference/ethereum-gettransactionreceipt#:~:text=eth_getTransactionReceipt%20is%20an%20Ethereum%20API,used%20to%20check%20transaction%20success))。この情報によって、アプリケーションはトランザクションが正式に完了したか、目的の処理（例えばトークン転送やコントラクトの実行）が成功したかを確認できます。

- **その他の関連メソッド**: `eth_getTransactionByHash`（ハッシュからトランザクションの内容を取得）、`eth_getTransactionCount`（アドレスの現在のnonceを取得）、`eth_estimateGas`（トランザクション実行に必要なガス量をシミュレーションで推定）など、開発に有用なRPCも提供されています ([eth_getTransactionReceipt RPC Method | Ethereum Documentation](https://www.quicknode.com/docs/ethereum/eth_getTransactionReceipt#:~:text=,eth_mining)) ([eth_getTransactionReceipt RPC Method | Ethereum Documentation](https://www.quicknode.com/docs/ethereum/eth_getTransactionReceipt#:~:text=,eth_getBlockReceipts))。

**フレームワークによるトランザクションハンドリング:** Web3.jsやEthers.jsといったライブラリは、上記RPC呼び出しを内部で行い開発者が扱いやすいAPIを提供しています。

- **Web3.js**: Web3.jsでは`web3.eth.sendTransaction(txObject)`を呼び出すことでトランザクション送信を行えます ([web3.eth — web3.js 1.0.0 documentation](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#:~:text=1.%20%60Object%60%20,object%20to%20send)) ([web3.eth — web3.js 1.0.0 documentation](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#:~:text=%2A%20%60gas%60%20,This%20allows%20to))。`txObject`に`from`,`to`,`value`等を指定すると、必要に応じてノードから`nonce`や`gasPrice`を取得し補完します。送り元アカウントがWeb3ウォレットに追加済みであれば、Web3.jsがその秘密鍵で**ローカル署名**を行い、内部的に`eth_sendRawTransaction`を呼び出してブロードキャストします ([web3.eth — web3.js 1.0.0 documentation](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#:~:text=Note))。反対に、ノードにアンロックされたアカウントを指定した場合は、ノード側に署名させるため`eth_sendTransaction`を使います ([web3.eth — web3.js 1.0.0 documentation](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#:~:text=Note))。Web3.jsの`sendTransaction`は**Promise**ベースで、送信直後にトランザクションハッシュを取得し、さらにプロミスが解決するタイミングでレシートを受け取るようになっています ([web3.eth — web3.js 1.0.0 documentation](https://web3js.readthedocs.io/en/v1.2.11/web3-eth.html#:~:text=The%20callback%20will%20return%20the,32%20bytes%20transaction%20hash))（内部的には`eth_getTransactionReceipt`のポーリングを行うか、イベント購読します）。

- **Ethers.js**: Ethers.jsでは**Signer**（サイナー）と呼ばれる抽象化を通じてトランザクション操作を行います ([Signers - Ethers.js](https://docs.ethers.org/v5/api/signer/#:~:text=A%20Signer%20in%20ethers%20is,transactions%20to%20the%20Ethereum))。例えば、開発者は自分の秘密鍵から`ethers.Wallet`インスタンスを作成し、それにプロバイダー（RPC接続）を紐付けてSignerとします ([  How to Send a Transaction Using Ethers.js | QuickNode Guides](https://www.quicknode.com/guides/ethereum-development/transactions/how-to-send-a-transaction-in-ethersjs#:~:text=%28async%20%28%29%20%3D,PRIVATE_KEY%2C%20provider))。このSignerで`sendTransaction({...})`メソッドを呼ぶと、Ethersが自動的に適切な`nonce`やガス関連パラメータを設定し、トランザクションに署名してRPCノードへ送信します ([  How to Send a Transaction Using Ethers.js | QuickNode Guides](https://www.quicknode.com/guides/ethereum-development/transactions/how-to-send-a-transaction-in-ethersjs#:~:text=const%20signer%20%3D%20new%20ethers,provider))。コード例を示すと、Ethers v5では以下のようになります ([  How to Send a Transaction Using Ethers.js | QuickNode Guides](https://www.quicknode.com/guides/ethereum-development/transactions/how-to-send-a-transaction-in-ethersjs#:~:text=const%20signer%20%3D%20new%20ethers,provider))。

  ```javascript
  const provider = new ethers.providers.JsonRpcProvider('https://<RPC_URL>');
  const signer = new ethers.Wallet(PRIVATE_KEY, provider);
  const tx = await signer.sendTransaction({
      to: '0x受信者アドレス...',
      value: ethers.utils.parseUnits('0.001', 'ether')
  });
  console.log(tx.hash);
  ```
  上記では`sendTransaction`を呼ぶだけで内部的に`eth_sendRawTransaction`が実行され、トランザクションハッシュを含むオブジェクトが返されています（コンソールにはそのハッシュを出力） ([  How to Send a Transaction Using Ethers.js | QuickNode Guides](https://www.quicknode.com/guides/ethereum-development/transactions/how-to-send-a-transaction-in-ethersjs#:~:text=const%20signer%20%3D%20new%20ethers,provider))。Ethersは送信後、自動的にトランザクションの完了を待つユーティリティ（例えば`tx.wait()`でレシート取得）も提供しており、開発者は低レベルなRPCを意識せず利用できます。

要するに、これらのフレームワークはトランザクション生成から署名、送信、結果取得までを高レベルAPIでカバーし、その裏でJSON-RPCの`eth_sendRawTransaction`や`eth_getTransactionReceipt`等を適切に呼び出しています。開発者は生のRLPエンコードや署名アルゴリズムを直接扱わずに済み、安全で確実なトランザクション処理を実装できるわけです。

## 3. デジタル署名の仕組みとブロックチェーン上での役割

**デジタル署名の概要:** デジタル署名とは、公開鍵暗号の原理を利用して**メッセージの認証と改ざん検知**を可能にする仕組みです。送信者は自分だけが知る秘密鍵でメッセージに署名を行い、受信者は対応する公開鍵でその署名を検証することで、以下を保証できます ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=Ethereum%20signatures%20are%20used%20to%3A)):

- **認証 (Authentication):** そのメッセージが確かに特定の送信者（秘密鍵の所有者）から送られたものであること ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=Ethereum%20signatures%20are%20used%20to%3A))。ブロックチェーンでは取引の送信者アドレスの所持者であることを証明します ([Ethereumの基本｜Ken @ インフラエンジニア](https://note.com/oh_yeahfire/n/nf3f190d394ff#:~:text=2))。
- **完全性 (Integrity):** メッセージが署名後に改ざんされていないこと ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=,deny%20having%20sent%20the%20transaction))。改ざんがあれば検証に失敗します。
- **非否認 (Non-repudiation):** 送信者は署名した事実を後から否認できないこと ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=,deny%20having%20sent%20the%20transaction))。署名は秘密鍵所有者にしか生成できないため、「自分は送っていない」と言い逃れできなくなります。

ブロックチェーンにおいて、トランザクションへのデジタル署名は極めて重要です。これによってネットワークの全ノードが「この取引は正当なアカウント所有者によって承認された」と検証でき、不正ななりすましや改ざんを排除しています ([Ethereumの基本｜Ken @ インフラエンジニア](https://note.com/oh_yeahfire/n/nf3f190d394ff#:~:text=2))。イーサリアムでは特に**楕円曲線デジタル署名アルゴリズム (ECDSA)**が用いられており、ビットコインと同じ`secp256k1`曲線上で署名が行われます ([The Magic of Digital Signatures on Ethereum | MyCrypto - Medium](https://medium.com/mycrypto/the-magic-of-digital-signatures-on-ethereum-98fe184dc9c7#:~:text=This%20is%20primarily%20used%20for,Ethereum%20uses%20the%20SECP256k1%20curve))。

**ECDSA（secp256k1）による署名と検証:** ECDSAは楕円曲線の数学に基づく署名アルゴリズムで、256ビットの秘密鍵と対応する公開鍵（座標形式で512ビット）を用います ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=,bit%20long))。Ethereumにおけるトランザクション署名の流れを簡略化すると次のようになります。

1. **メッセージハッシュの作成:** 署名対象であるトランザクションデータをハッシュ化します。具体的には、トランザクションの主要フィールド（nonceやto, value, gas情報, dataなど）をRLPエンコードし、Keccak-256(256ビットのハッシュ関数)でハッシュ値を求めます ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=,produce%20a%20signature%20using%20ECDSA))。このハッシュが署名アルゴリズムへの入力となります。
2. **署名の生成:** ハッシュ値と自分の秘密鍵を用いてECDSA署名を計算します ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=,produce%20a%20signature%20using%20ECDSA))。計算により*`r`*と*`s`*という2つの大きな整数が得られます。さらに、署名から後で公開鍵を復元できるように、リカバリ識別子*`v`*も付加します ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=The%20signature%20consists%20of%20three,components%3A%20r%2C%20s%2C%20and%20v))。Ethereumの署名は最終的に*(r, s, v)*の3つ組で表され、65バイト（r32 + s32 + v1）になります。vは通常0または1ですが、イーサリアムではチェーンIDを組み込む仕様(EIP-155)によりメインネットでは27/28（もしくは他チェーンではそれに2*chainIdを加えた値）として格納されます。こうして得られた署名値*(r, s, v)*をトランザクション本体に付加することで、署名済みトランザクションが完成します ([東大生がSolidity0.8.14マニュアル読み込んでみた-Basics-｜現役東大生コウくんのsolidity日記](https://note.com/koseirving/n/n6f710238ddf5#:~:text=%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%ABECDSA%E7%BD%B2%E5%90%8D%E3%81%AFr%E3%81%A8s%E3%81%A8%E3%81%84%E3%81%862%E3%81%A4%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E6%A7%8B%E6%88%90%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82Ethereum%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%AFv%E3%81%A8%E3%81%84%E3%81%863%E3%81%A4%E7%9B%AE%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%A9%20%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E7%A7%98%E5%AF%86%E9%8D%B5%E3%81%8C%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%8B%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E3%81%9D%E3%81%AE%E5%8F%96%E5%BC%95%E3%81%AE%E9%80%81%E3%82%8A%E4%B8%BB%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Solidity%20%E3%81%AB%E3%81%AF%20%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E9%96%A2%E6%95%B0,ecrecover%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%A8%20r%E3%80%81s%E3%80%81v%20%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%94%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。
3. **ネットワークでの検証:** ノードは受け取ったトランザクションからハッシュを再計算し、付与された*(r,s,v)*署名を検証します。検証では公開鍵（またはアドレス）とメッセージハッシュから署名が正しいことを確認します ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=Signature%20Verification))。具体的には、まず*v*から署名に対応する公開鍵を復元します（`secp256k1`では署名から可能な公開鍵が2通りあり、vでその選択肢を示します） ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=The%20signature%20consists%20of%20three,components%3A%20r%2C%20s%2C%20and%20v))。復元した公開鍵をKeccak-256でハッシュし、その下位20バイトを取ることでイーサリアムアドレスを得ます。これがトランザクションの送信元アドレスと一致すれば署名者認証成功です ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=Signature%20Verification))。また同時に、楕円曲線上の計算（公開鍵と(r,s)から元のハッシュが導けるか）によって署名そのものの整合性もチェックします。これらが有効であればトランザクションは正当なものとして処理されます。

このように、デジタル署名により各トランザクションは<strong>誰が</strong>発信し<strong>何を</strong>しようとしているかを改ざん不可能な形で証明しています ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=Ethereum%20signatures%20are%20used%20to%3A))。特にパブリックなブロックチェーンでは匿名の多数のノードが取引を検証するため、各ノードが独立に署名の正当性をチェックできること（=秘密鍵がなくても公開鍵で検証できること）が不可欠です。

**Zigにおけるデジタル署名実装例:** Zig言語でECDSA署名を扱う場合、低レベルの暗号ライブラリを利用することが一般的です。例えば、ビットコインやEthereumで広く使われているC言語製のライブラリ**libsecp256k1**をZigから呼び出すことで、署名や検証の機能を実装できます。実際、Zig製のEthereumライブラリである**Zabi**ではウォレット機能（鍵管理と署名生成）にlibsecp256k1を組み込み、Zigからシームレスに利用しています ([Zabi - Interact with EVM based chains via Zig! : r/Zig](https://www.reddit.com/r/Zig/comments/1b84sws/zabi_interact_with_evm_based_chains_via_zig/#:~:text=Here%20are%20some%20of%20the,EIP4844%20blobs%20and%20KZG%20commitments))。「署名の魔法」とも言われるこの部分は既に確立されたアルゴリズムなので、一から楕円曲線演算を実装するより、既存ライブラリのラッパーを使う方が安全かつ効率的です ([Zabi - Interact with EVM based chains via Zig! : r/Zig](https://www.reddit.com/r/Zig/comments/1b84sws/zabi_interact_with_evm_based_chains_via_zig/#:~:text=Here%20are%20some%20of%20the,EIP4844%20blobs%20and%20KZG%20commitments))。ZigはCとの相互運用性が高く、`@cImport`機能でlibsecp256k1の関数を直接呼び出したり、あるいは有志によるZigラッパーパッケージ（例えば*zig-eth-secp256k1* ([GitHub - jsign/zig-eth-secp256k1: A Zig libsecp256k1 wrapper with bells and whistles for Ethereum](https://github.com/jsign/zig-eth-secp256k1#:~:text=Topics))）を利用できます。

Zig標準ライブラリ自体もハッシュ関数など基本的な暗号プリミティブを提供しています。例えばKeccak-256（SHA3）ハッシュの実装が含まれており、トランザクションハッシュ計算に利用できます ([zig/lib/std/crypto.zig at master · ziglang/zig · GitHub](https://github.com/ziglang/zig/blob/master/lib/std/crypto.zig#:~:text=pub%20const%20aes%20%3D%20%40import%28))。これとlibsecp256k1を組み合わせれば、Ethereumのトランザクション署名(`secp256k1( Keccak256(RLP(tx)) )`)をZig上で行うことが可能です。検証も同様で、署名(r,s,v)とメッセージハッシュから公開鍵を復元し ([東大生がSolidity0.8.14マニュアル読み込んでみた-Basics-｜現役東大生コウくんのsolidity日記](https://note.com/koseirving/n/n6f710238ddf5#:~:text=%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%ABECDSA%E7%BD%B2%E5%90%8D%E3%81%AFr%E3%81%A8s%E3%81%A8%E3%81%84%E3%81%862%E3%81%A4%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E6%A7%8B%E6%88%90%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82Ethereum%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%AFv%E3%81%A8%E3%81%84%E3%81%863%E3%81%A4%E7%9B%AE%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%A9%20%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E7%A7%98%E5%AF%86%E9%8D%B5%E3%81%8C%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%8B%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E3%81%9D%E3%81%AE%E5%8F%96%E5%BC%95%E3%81%AE%E9%80%81%E3%82%8A%E4%B8%BB%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Solidity%20%E3%81%AB%E3%81%AF%20%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E9%96%A2%E6%95%B0,ecrecover%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%A8%20r%E3%80%81s%E3%80%81v%20%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%94%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))、そのアドレスを計算して一致を確認する処理を実装できます。まとめると、Zigにおけるデジタル署名の実装は「ハッシュ計算 → 署名生成/検証」の流れをCライブラリやZig標準機能で組み立てる形になります。

## 4. Zigでのトランザクション実装プラン

上記の知見を踏まえ、Zigでイーサリアムのトランザクション発行・署名・検証を行う機能を設計する際のポイントを整理します。

- **データ構造の定義:** まずトランザクションを表現する構造体を設計します。例えば以下のようなフィールドを持つ`Transaction`構造体を定義できます: `nonce`, `to`（20バイトアドレス）, `value`（Uint256）, `gasLimit`, `gasPrice`（またはEIP-1559のフィー構造）, `data`（可変長バイト列）など。また署名付きトランザクションを扱うため、`v,r,s`フィールドや署名全体のバイト列を保持する`SignedTransaction`構造体を用意します。

- **RLPエンコード/デコード:** Ethereum取引のシリアライズ形式であるRLP（Recursive Length Prefix）を扱えるようにします。ブロックチェーンへのブロードキャスト時やハッシュ計算時にRLPエンコードされたバイト列が必要になるためです。ZigでRLPを実装するか、既存の実装があれば利用します。前述のZabiライブラリでもRLPのエンコード/デコード機能がサポートされており ([Zabi - Interact with EVM based chains via Zig! : r/Zig](https://www.reddit.com/r/Zig/comments/1b84sws/zabi_interact_with_evm_based_chains_via_zig/#:~:text=Here%20are%20some%20of%20the,EIP4844%20blobs%20and%20KZG%20commitments))、これを参考にできます。

- **署名生成機能:** 秘密鍵からトランザクションに署名する関数を実装します。手順は、(1)トランザクション構造体をRLPエンコード（署名フィールドを除外し、EIP-155準拠なら`chainId`とダミーの`0,0`を追加）しハッシュ化 ([Signing Transactions Using Post-Quantum Keys - LACNet](https://www.lacnet.com/signing-transactions-using-post-quantum-keys/#:~:text=Signing%20Transactions%20Using%20Post,For%20consistency))、(2)そのハッシュをsecp256k1曲線上で署名し*r,s*を得る、(3)チェーンIDに応じて*v*値を算出し、署名をトランザクションに埋め込みます。具体的な実装は、上述のようにZigからlibsecp256k1の`ecdsa_sign`的な関数を呼び出す方法が考えられます ([Zabi - Interact with EVM based chains via Zig! : r/Zig](https://www.reddit.com/r/Zig/comments/1b84sws/zabi_interact_with_evm_based_chains_via_zig/#:~:text=Here%20are%20some%20of%20the,EIP4844%20blobs%20and%20KZG%20commitments))。Zigで乱数（署名に必要な一時値k）を安全に生成し、署名アルゴリズムに渡します。署名結果の*r,s,v*を取得したら、`SignedTransaction`構造体に格納します。

- **署名検証機能:** 受け取った署名付きトランザクションが正当か検証する関数も用意します。これはノード側の処理に相当します。具体的には、(1)署名付きトランザクションから署名部分*v,r,s*を取り出し、残りのフィールドをRLPエンコードしてハッシュ化、(2) libsecp256k1の公開鍵復元関数（e.g. `ecdsa_recover`）にハッシュと*r,s*と*v*を渡し公開鍵を得る、(3)公開鍵からアドレスを導出しトランザクションの`from`（あるいは署名者アドレス）と比較、(4)さらにnonceの妥当性や残高チェックを行います ([東大生がSolidity0.8.14マニュアル読み込んでみた-Basics-｜現役東大生コウくんのsolidity日記](https://note.com/koseirving/n/n6f710238ddf5#:~:text=%E4%B8%80%E8%88%AC%E7%9A%84%E3%81%ABECDSA%E7%BD%B2%E5%90%8D%E3%81%AFr%E3%81%A8s%E3%81%A8%E3%81%84%E3%81%862%E3%81%A4%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%81%A7%E6%A7%8B%E6%88%90%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82Ethereum%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E3%81%AFv%E3%81%A8%E3%81%84%E3%81%863%E3%81%A4%E7%9B%AE%E3%81%AE%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%81%9D%E3%82%8C%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%A9%20%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E7%A7%98%E5%AF%86%E9%8D%B5%E3%81%8C%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E3%82%8F%E3%82%8C%E3%81%9F%E3%81%8B%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6%E3%81%9D%E3%81%AE%E5%8F%96%E5%BC%95%E3%81%AE%E9%80%81%E3%82%8A%E4%B8%BB%E3%82%92%E7%A2%BA%E8%AA%8D%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Solidity%20%E3%81%AB%E3%81%AF%20%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E9%96%A2%E6%95%B0,ecrecover%20%E3%81%8C%E3%81%82%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%A8%20r%E3%80%81s%E3%80%81v%20%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E3%82%92%E5%8F%97%E3%81%91%E5%8F%96%E3%82%8A%E3%80%81%E3%83%A1%E3%83%83%E3%82%BB%E3%83%BC%E3%82%B8%E3%81%B8%E3%81%AE%E7%BD%B2%E5%90%8D%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%9F%E3%82%A2%E3%83%89%E3%83%AC%E3%82%B9%E3%82%92%E8%BF%94%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。これらをすべてパスすれば署名検証成功とみなし、トランザクションを次の処理に進めます。Zigならこの一連の処理を関数`verifyTransaction(signedTx: SignedTransaction) bool`のように実装できます。

- **API設計:** 外部からトランザクションを追加できるインターフェースを検討します。例えば、自前の簡易ノードやmempoolをZigで構築する場合、外部モジュールが呼び出せる関数として`submitTransaction(rawTx: []u8) !void`を用意します。この関数内で、生のトランザクションバイト列をデコードし（RLPデコード）、上記の`verifyTransaction`で署名や各種チェックを行い、問題なければ内部のトランザクションプール（キュー）に追加します。こうすることで、ネットワークや他のアプリから受け取ったトランザクションをZigプログラム内に取り込み処理することができます。

- **ブロードキャストとブロック生成（必要に応じて）:** 実装の目的によっては、さらにその先の処理も設計します。例えば自前のブロックチェーンをZigで実装しているなら、プールしたトランザクションを選択してブロックを組み立て、RLPでまとめてハッシュを計算し、新しいブロックを生成・検証する部分も必要です。その際各トランザクションを実行してステートツリーを更新し、トランザクションレシートを作る処理も実装範囲に入ります。しかしEthereum本体の再現は非常に大規模になるため、ウォレットや簡易クライアント実装であれば上述したトランザクションの作成・署名・ネットワーク送信と、受信トランザクションの検証あたりまでを担当すれば十分でしょう。

以上の設計により、Zig上でEthereumトランザクションを自在に生成・署名し、また受け取ったトランザクションの検証・管理が可能になります。実装のキモは**Keccak256ハッシュ**と**ECDSA(secp256k1)**の扱いであり、Zigからこれらを利用するために標準ライブラリ＋既存の暗号ライブラリを組み合わせる形になります。 ([Zabi - Interact with EVM based chains via Zig! : r/Zig](https://www.reddit.com/r/Zig/comments/1b84sws/zabi_interact_with_evm_based_chains_via_zig/#:~:text=Here%20are%20some%20of%20the,EIP4844%20blobs%20and%20KZG%20commitments))で触れられている通り、RLPやABIの処理、secp256k1によるウォレット機能など、Ethereum特有の要素は既にZigでもプロジェクトが進められています。これらを参考にしつつ、自身のユースケースに合わせたAPI（例えばトランザクションを組み立てて送信する`sendTransaction`関数や、取引プールに追加する`addPendingTransaction`関数など）を設計すると良いでしょう。

最後に、Zigで低レベルからトランザクション処理を実装・学習することは、ブロックチェーンの仕組みを深く理解する助けになります。署名一つとっても、その裏にある暗号理論（楕円曲線の演算やハッシュ関数）を触る機会となり、有意義です。完成した実装を用いれば、Zig製のウォレットや簡易ノードを構築して実際にイーサリアムネットワークとやりとりすることも可能であり、学術的にも実用的にも価値のあるプロジェクトとなるでしょう。

**参考文献:** イーサリアム公式ドキュメント ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E3%83%90%E3%83%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%81%B8%E3%81%AE%E3%83%81%E3%83%83%E3%83%97%E3%81%A8%E3%81%97%E3%81%A6%E5%90%AB%E3%82%81%E3%82%8B%E9%9A%9B%E3%81%AB%E6%B6%88%E8%B2%BB%E3%81%95%E3%82%8C%E3%82%8B%E3%82%AC%E3%82%B9%E4%BB%A3%E3%81%AE%E4%B8%8A%E9%99%90%E3%80%82)) ([トランザクション](https://ethereum.org/ja/developers/docs/transactions/#:~:text=,%E3%82%92%E5%90%AB%E3%82%80))、QuickNodeガイド ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=Ethereum%20signatures%20are%20used%20to%3A)) ([How to Verify Message Signatures on Ethereum | QuickNode Guides](https://www.quicknode.com/guides/web3-fundamentals-security/cryptography/verify-message-signature-on-ethereum#:~:text=The%20signature%20consists%20of%20three,components%3A%20r%2C%20s%2C%20and%20v))、Ethereum StackExchange ([What is the ethereum transaction data structure? - Ethereum Stack Exchange](https://ethereum.stackexchange.com/questions/1990/what-is-the-ethereum-transaction-data-structure#:~:text=An%20Ethereum%20transaction%20,part%20of%20the%20encoded%20data))、Zig/Ethereumコミュニティ資料 ([Zabi - Interact with EVM based chains via Zig! : r/Zig](https://www.reddit.com/r/Zig/comments/1b84sws/zabi_interact_with_evm_based_chains_via_zig/#:~:text=Here%20are%20some%20of%20the,EIP4844%20blobs%20and%20KZG%20commitments))など。各リンク先でさらに詳細な解説を参照できます。
